/*
 * generated by Xtext
 */
package org.xtext.DOE.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.DOE.experimentOntology.CoherenceLink;
import org.xtext.DOE.experimentOntology.Condition;
import org.xtext.DOE.experimentOntology.ControlVariables;
import org.xtext.DOE.experimentOntology.DependentVariables;
import org.xtext.DOE.experimentOntology.Design;
import org.xtext.DOE.experimentOntology.Dispersed;
import org.xtext.DOE.experimentOntology.EventDescriptor;
import org.xtext.DOE.experimentOntology.Evidence;
import org.xtext.DOE.experimentOntology.Experiment;
import org.xtext.DOE.experimentOntology.ExperimentOntologyPackage;
import org.xtext.DOE.experimentOntology.Factor;
import org.xtext.DOE.experimentOntology.FactorLevels;
import org.xtext.DOE.experimentOntology.Goals;
import org.xtext.DOE.experimentOntology.GuardCondition;
import org.xtext.DOE.experimentOntology.Hypothesis;
import org.xtext.DOE.experimentOntology.IndependentVariables;
import org.xtext.DOE.experimentOntology.Iteration;
import org.xtext.DOE.experimentOntology.MechHypothesis;
import org.xtext.DOE.experimentOntology.Mechanism;
import org.xtext.DOE.experimentOntology.Model;
import org.xtext.DOE.experimentOntology.ModelSection;
import org.xtext.DOE.experimentOntology.PerformanceMeasure;
import org.xtext.DOE.experimentOntology.Query1;
import org.xtext.DOE.experimentOntology.Query2;
import org.xtext.DOE.experimentOntology.Query3;
import org.xtext.DOE.experimentOntology.Reaction;
import org.xtext.DOE.experimentOntology.Response;
import org.xtext.DOE.experimentOntology.Simultaneous;
import org.xtext.DOE.experimentOntology.Values;
import org.xtext.DOE.experimentOntology.Variables;
import org.xtext.DOE.experimentOntology.properties;
import org.xtext.DOE.services.ExperimentOntologyGrammarAccess;

@SuppressWarnings("all")
public class ExperimentOntologySemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ExperimentOntologyGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == ExperimentOntologyPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case ExperimentOntologyPackage.COHERENCE_LINK:
				sequence_CoherenceLink(context, (CoherenceLink) semanticObject); 
				return; 
			case ExperimentOntologyPackage.CONDITION:
				if(context == grammarAccess.getConditionRule()) {
					sequence_Condition(context, (Condition) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getTemporalPatternRule()) {
					sequence_Condition_TemporalPattern(context, (Condition) semanticObject); 
					return; 
				}
				else break;
			case ExperimentOntologyPackage.CONTROL_VARIABLES:
				sequence_ControlVariables(context, (ControlVariables) semanticObject); 
				return; 
			case ExperimentOntologyPackage.DEPENDENT_VARIABLES:
				sequence_DependentVariables(context, (DependentVariables) semanticObject); 
				return; 
			case ExperimentOntologyPackage.DESIGN:
				sequence_Design(context, (Design) semanticObject); 
				return; 
			case ExperimentOntologyPackage.DISPERSED:
				sequence_Dispersed(context, (Dispersed) semanticObject); 
				return; 
			case ExperimentOntologyPackage.EVENT_DESCRIPTOR:
				sequence_EventDescriptor(context, (EventDescriptor) semanticObject); 
				return; 
			case ExperimentOntologyPackage.EVIDENCE:
				sequence_Evidence(context, (Evidence) semanticObject); 
				return; 
			case ExperimentOntologyPackage.EXPERIMENT:
				sequence_Experiment(context, (Experiment) semanticObject); 
				return; 
			case ExperimentOntologyPackage.FACTOR:
				sequence_Factor(context, (Factor) semanticObject); 
				return; 
			case ExperimentOntologyPackage.FACTOR_LEVELS:
				sequence_FactorLevels(context, (FactorLevels) semanticObject); 
				return; 
			case ExperimentOntologyPackage.GOALS:
				sequence_Goals(context, (Goals) semanticObject); 
				return; 
			case ExperimentOntologyPackage.GUARD_CONDITION:
				sequence_GuardCondition(context, (GuardCondition) semanticObject); 
				return; 
			case ExperimentOntologyPackage.HYPOTHESIS:
				sequence_Hypothesis(context, (Hypothesis) semanticObject); 
				return; 
			case ExperimentOntologyPackage.INDEPENDENT_VARIABLES:
				sequence_IndependentVariables(context, (IndependentVariables) semanticObject); 
				return; 
			case ExperimentOntologyPackage.ITERATION:
				sequence_Iteration(context, (Iteration) semanticObject); 
				return; 
			case ExperimentOntologyPackage.MECH_HYPOTHESIS:
				sequence_MechHypothesis(context, (MechHypothesis) semanticObject); 
				return; 
			case ExperimentOntologyPackage.MECHANISM:
				sequence_Mechanism(context, (Mechanism) semanticObject); 
				return; 
			case ExperimentOntologyPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ExperimentOntologyPackage.MODEL_SECTION:
				sequence_ModelSection(context, (ModelSection) semanticObject); 
				return; 
			case ExperimentOntologyPackage.PERFORMANCE_MEASURE:
				sequence_PerformanceMeasure(context, (PerformanceMeasure) semanticObject); 
				return; 
			case ExperimentOntologyPackage.QUERY1:
				sequence_Query1(context, (Query1) semanticObject); 
				return; 
			case ExperimentOntologyPackage.QUERY2:
				sequence_Query2(context, (Query2) semanticObject); 
				return; 
			case ExperimentOntologyPackage.QUERY3:
				sequence_Query3(context, (Query3) semanticObject); 
				return; 
			case ExperimentOntologyPackage.REACTION:
				sequence_Reaction(context, (Reaction) semanticObject); 
				return; 
			case ExperimentOntologyPackage.RESPONSE:
				sequence_Response(context, (Response) semanticObject); 
				return; 
			case ExperimentOntologyPackage.SIMULTANEOUS:
				sequence_Simultaneous(context, (Simultaneous) semanticObject); 
				return; 
			case ExperimentOntologyPackage.VALUES:
				sequence_Values(context, (Values) semanticObject); 
				return; 
			case ExperimentOntologyPackage.VARIABLES:
				sequence_Variables(context, (Variables) semanticObject); 
				return; 
			case ExperimentOntologyPackage.PROPERTIES:
				sequence_properties(context, (properties) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (coherence=Coherence hyp+=ID* evi+=ID*)
	 */
	protected void sequence_CoherenceLink(EObject context, CoherenceLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (condition=Event lo=LinkOperators? e=Event? exp1=Expression? v=rangeValue?)
	 */
	protected void sequence_Condition(EObject context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         condition=Event 
	 *         lo=LinkOperators? 
	 *         e=Event? 
	 *         exp1=Expression? 
	 *         v=rangeValue? 
	 *         l2+=Links* 
	 *         exp+=Expression* 
	 *         (op1+=Temporal | op2+=Logical)* 
	 *         l3=Links?
	 *     )
	 */
	protected void sequence_Condition_TemporalPattern(EObject context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (controlName=ID controlType=VariableType controlValue=Values)*
	 */
	protected void sequence_ControlVariables(EObject context, ControlVariables semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.CONTROL_VARIABLES__CONTROL_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.CONTROL_VARIABLES__CONTROL_NAME));
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.CONTROL_VARIABLES__CONTROL_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.CONTROL_VARIABLES__CONTROL_TYPE));
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.CONTROL_VARIABLES__CONTROL_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.CONTROL_VARIABLES__CONTROL_VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getControlVariablesAccess().getControlNameIDTerminalRuleCall_3_0_0(), semanticObject.getControlName());
		feeder.accept(grammarAccess.getControlVariablesAccess().getControlTypeVariableTypeEnumRuleCall_3_3_0(), semanticObject.getControlType());
		feeder.accept(grammarAccess.getControlVariablesAccess().getControlValueValuesParserRuleCall_3_7_0(), semanticObject.getControlValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     responseName=Response*
	 */
	protected void sequence_DependentVariables(EObject context, DependentVariables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (designType=DesignType? constraint=ID* iteration=Iteration? variables=Variables)
	 */
	protected void sequence_Design(EObject context, Design semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     disp+=Re+
	 */
	protected void sequence_Dispersed(EObject context, Dispersed semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (eventName=ID event=STRING)
	 */
	protected void sequence_EventDescriptor(EObject context, EventDescriptor semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.EVENT_DESCRIPTOR__EVENT_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.EVENT_DESCRIPTOR__EVENT_NAME));
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.EVENT_DESCRIPTOR__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.EVENT_DESCRIPTOR__EVENT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEventDescriptorAccess().getEventNameIDTerminalRuleCall_1_0(), semanticObject.getEventName());
		feeder.accept(grammarAccess.getEventDescriptorAccess().getEventSTRINGTerminalRuleCall_3_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (eName=ID query+=TemporalPattern* objOfStudy=rangeValue)
	 */
	protected void sequence_Evidence(EObject context, Evidence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expName=ID expDesign=Design perfMeasure=PerformanceMeasure)
	 */
	protected void sequence_Experiment(EObject context, Experiment semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.EXPERIMENT__EXP_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.EXPERIMENT__EXP_NAME));
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.EXPERIMENT__EXP_DESIGN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.EXPERIMENT__EXP_DESIGN));
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.EXPERIMENT__PERF_MEASURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.EXPERIMENT__PERF_MEASURE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExperimentAccess().getExpNameIDTerminalRuleCall_1_0(), semanticObject.getExpName());
		feeder.accept(grammarAccess.getExperimentAccess().getExpDesignDesignParserRuleCall_4_0(), semanticObject.getExpDesign());
		feeder.accept(grammarAccess.getExperimentAccess().getPerfMeasurePerformanceMeasureParserRuleCall_7_0(), semanticObject.getPerfMeasure());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (facName=ID l=factorLevelValue? (l1=Levels l2=Levels start1=rangeValue end1=rangeValue)?)
	 */
	protected void sequence_FactorLevels(EObject context, FactorLevels semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (factorName=ID factorType=VariableType? factorType1=ID? factorValue=Values? factorProperties+=properties*)
	 */
	protected void sequence_Factor(EObject context, Factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (objOfStudy=STRING purpose=STRING focus=STRING viewPoint=STRING context=STRING)
	 */
	protected void sequence_Goals(EObject context, Goals semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.GOALS__OBJ_OF_STUDY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.GOALS__OBJ_OF_STUDY));
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.GOALS__PURPOSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.GOALS__PURPOSE));
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.GOALS__FOCUS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.GOALS__FOCUS));
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.GOALS__VIEW_POINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.GOALS__VIEW_POINT));
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.GOALS__CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.GOALS__CONTEXT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getGoalsAccess().getObjOfStudySTRINGTerminalRuleCall_6_0(), semanticObject.getObjOfStudy());
		feeder.accept(grammarAccess.getGoalsAccess().getPurposeSTRINGTerminalRuleCall_9_0(), semanticObject.getPurpose());
		feeder.accept(grammarAccess.getGoalsAccess().getFocusSTRINGTerminalRuleCall_12_0(), semanticObject.getFocus());
		feeder.accept(grammarAccess.getGoalsAccess().getViewPointSTRINGTerminalRuleCall_15_0(), semanticObject.getViewPoint());
		feeder.accept(grammarAccess.getGoalsAccess().getContextSTRINGTerminalRuleCall_18_0(), semanticObject.getContext());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (gd='[' condition1=ID? link=LinkOperators? condition2=ID?)
	 */
	protected void sequence_GuardCondition(EObject context, GuardCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (mechHypothesis+=MechHypothesis* evidences+=Evidence* coherenceLinks+=CoherenceLink* relHypothesis+=RelationalQuery*)
	 */
	protected void sequence_Hypothesis(EObject context, Hypothesis semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     variables+=FactorLevels*
	 */
	protected void sequence_IndependentVariables(EObject context, IndependentVariables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     iterations=INT
	 */
	protected void sequence_Iteration(EObject context, Iteration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.ITERATION__ITERATIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.ITERATION__ITERATIONS));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIterationAccess().getIterationsINTTerminalRuleCall_4_0(), semanticObject.getIterations());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (mName=ID assoMech+=TemporalPattern* mechanisticHypothesis=ID?)
	 */
	protected void sequence_MechHypothesis(EObject context, MechHypothesis semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (mechanismName=ID LHS=Reaction condition=GuardCondition? RHS=Reaction)
	 */
	protected void sequence_Mechanism(EObject context, Mechanism semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (modName=ID mechanisms+=Mechanism* events+=EventDescriptor* parameters+=Factor*)
	 */
	protected void sequence_ModelSection(EObject context, ModelSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     elements+=ExperimentOntology*
	 */
	protected void sequence_Model(EObject context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expectedResponse=ID er=rangeValue std=rangeValue)
	 */
	protected void sequence_PerformanceMeasure(EObject context, PerformanceMeasure semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.PERFORMANCE_MEASURE__EXPECTED_RESPONSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.PERFORMANCE_MEASURE__EXPECTED_RESPONSE));
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.PERFORMANCE_MEASURE__ER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.PERFORMANCE_MEASURE__ER));
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.PERFORMANCE_MEASURE__STD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.PERFORMANCE_MEASURE__STD));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPerformanceMeasureAccess().getExpectedResponseIDTerminalRuleCall_1_0(), semanticObject.getExpectedResponse());
		feeder.accept(grammarAccess.getPerformanceMeasureAccess().getErRangeValueTerminalRuleCall_3_0(), semanticObject.getEr());
		feeder.accept(grammarAccess.getPerformanceMeasureAccess().getStdRangeValueTerminalRuleCall_5_0(), semanticObject.getStd());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         factor=ID? 
	 *         control=ID? 
	 *         x=rangeValue? 
	 *         (start1=rangeValue end1=rangeValue)? 
	 *         response=ID 
	 *         y=rangeValue? 
	 *         (start2=rangeValue end2=rangeValue)?
	 *     )
	 */
	protected void sequence_Query1(EObject context, Query1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         function1=Function? 
	 *         response1=ID? 
	 *         factor1=ID? 
	 *         function2=Function? 
	 *         response2=ID? 
	 *         factor2=ID?
	 *     )
	 */
	protected void sequence_Query2(EObject context, Query2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (factor1=ID? control1=ID? Level2=Levels? x2=rangeValue?)* 
	 *         (response1=ID Level4=Levels? x4=rangeValue?)* 
	 *         (
	 *             level=Levels 
	 *             factor=ID? 
	 *             control=ID? 
	 *             response=ID? 
	 *             start1=rangeValue 
	 *             end1=rangeValue
	 *         )*
	 *     )
	 */
	protected void sequence_Query3(EObject context, Query3 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (agent1=ID agent=ID?)
	 */
	protected void sequence_Reaction(EObject context, Reaction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (responseName=ID responseType=ResponseType)
	 */
	protected void sequence_Response(EObject context, Response semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.RESPONSE__RESPONSE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.RESPONSE__RESPONSE_NAME));
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.RESPONSE__RESPONSE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.RESPONSE__RESPONSE_TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getResponseAccess().getResponseNameIDTerminalRuleCall_0_0(), semanticObject.getResponseName());
		feeder.accept(grammarAccess.getResponseAccess().getResponseTypeResponseTypeEnumRuleCall_3_0(), semanticObject.getResponseType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (sim1=Re (log+=Logical sim2+=Re)*)
	 */
	protected void sequence_Simultaneous(EObject context, Simultaneous semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (fVal=ID? function=STRING? value=rangeValue? fvalue=factorLevelValue?)
	 */
	protected void sequence_Values(EObject context, Values semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (independentVariables=IndependentVariables controlVariables=ControlVariables? dependentVariables=DependentVariables)
	 */
	protected void sequence_Variables(EObject context, Variables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (pName=ID pVal=Values)
	 */
	protected void sequence_properties(EObject context, properties semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.PROPERTIES__PNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.PROPERTIES__PNAME));
			if(transientValues.isValueTransient(semanticObject, ExperimentOntologyPackage.Literals.PROPERTIES__PVAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExperimentOntologyPackage.Literals.PROPERTIES__PVAL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPropertiesAccess().getPNameIDTerminalRuleCall_0_0(), semanticObject.getPName());
		feeder.accept(grammarAccess.getPropertiesAccess().getPValValuesParserRuleCall_2_0(), semanticObject.getPVal());
		feeder.finish();
	}
}
